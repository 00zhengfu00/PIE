<PUBLIC:COMPONENT lightWeight="true">
    <PUBLIC:ATTACH EVENT="onresize" FOR="element" ONEVENT="update()" />
    <PUBLIC:ATTACH EVENT="onresize" FOR="window" ONEVENT="update()" /><!-- for IE8 -->
    <PUBLIC:ATTACH EVENT="onmove" FOR="element" ONEVENT="update()" />
    <PUBLIC:ATTACH EVENT="onpropertychange" FOR="element" ONEVENT="propChanged()" />
    <PUBLIC:ATTACH EVENT="oncontentready" FOR="element" ONEVENT="init()" />
    <PUBLIC:ATTACH EVENT="ondetach" FOR="element" ONEVENT="cleanup()" />

    <script type="text/javascript">

        var lastW, lastH, lastX, lastY,
            renderers,
            styleInfos,
            ancestors,
            PIE = window.PIE;


        if( !PIE ) {
            PIE = window.PIE = {
                CSS_PREFIX: '-pie-',
                STYLE_PREFIX: 'Pie'
            };

            // Detect IE6
            if( !window.XMLHttpRequest ) {
                PIE.isIE6 = true;

                // IE6 can't access properties with leading dash, but can without it.
                PIE.CSS_PREFIX = PIE.CSS_PREFIX.replace( /^-/, '' );
            }

            /**
             * To create a VML element, it must be created by a Document which has the VML
             * namespace set. Unfortunately, if you try to add the namespace programatically
             * into the main document, you will get an "Unspecified error" when trying to
             * access document.namespaces before the document is finished loading. To get
             * around this, we create a DocumentFragment, which in IE land is apparently a
             * full-fledged Document. It allows adding namespaces immediately, so we add the
             * namespace there and then have it create the VML element.
             */
            PIE.createVmlElement = function( tag ) {
                var vmlPrefix = 'css3vml',
                    vmlDoc = PIE._vmlCreatorDoc;
                if( !vmlDoc ) {
                    vmlDoc = PIE._vmlCreatorDoc = element.document.createDocumentFragment();
                    vmlDoc.namespaces.add( vmlPrefix, 'urn:schemas-microsoft-com:vml' );
                }
                return vmlDoc.createElement( vmlPrefix + ':' + tag );
            };


            PIE.merge = function( obj1 ) {
                var i, len, p, objN, args = arguments;
                for( i = 1, len = args.length; i < len; i++ ) {
                    objN = args[i];
                    for( p in objN ) {
                        if( objN.hasOwnProperty( p ) ) {
                            obj1[ p ] = objN[ p ];
                        }
                    }
                }
                return obj1;
            };


            /**
             * Execute a callback function, passing it the dimensions of a given image once
             * they are known.
             */
            PIE.withImageSize = function( src, func, ctx ) {
                var sizes = PIE._imgSizes || ( PIE._imgSizes = {} ),
                    size = sizes[ src ], img;
                if( size ) {
                    func.call( ctx, size );
                } else {
                    img = new Image();
                    img.onload = function() {
                        size = sizes[ src ] = { w: img.width, h: img.height };
                        func.call( ctx, size );
                    };
                    img.src = src;
                }
            };


            /**
             * Wrapper for length style values
             * @param val - the CSS string representing the length. It is assumed that this will already have
             *              been validated as a valid length or percentage syntax.
             */
            PIE.Length = ( function() {
                function Length( val ) {
                    this.val = val;
                }
                Length.prototype = {
                    unitRE: /(px|em|ex|mm|cm|in|pt|pc|%)$/,

                    getNumber: function() {
                        var num = this._number;
                        if( num === undefined ) {
                            num = this._number = parseFloat( this.val );
                        }
                        return num;
                    },

                    getUnit: function() {
                        var unit = this._unit, m;
                        if( !unit ) {
                            m = this.val.match( this.unitRE );
                            unit = this._unit = ( m && m[0] ) || 'px';
                        }
                        return unit;
                    },

                    isPercentage: function() {
                        return this.getUnit() === '%';
                    },

                    /**
                     * Resolve this length into a number of pixels.
                     * @param el - the context element, used to resolve font-relative values
                     * @param pct100 - the number of pixels that equal a 100% percentage. This can be either a number or a
                     *                 function which will be called to return the number.
                     */
                    pixels: function( el, pct100 ) {
                        var num = this.getNumber(),
                            unit = this.getUnit();
                        switch( unit ) {
                            case "px":
                                return num;
                            case "%":
                                return num * ( typeof pct100 === 'function' ? pct100() : pct100 ) / 100;
                            case "em":
                                return num * this.getEmPixels( el );
                            case "ex":
                                return num * this.getEmPixels( el ) / 2;
                            default:
                                return num * Length.conversions[ unit ];
                        }
                    },

                    /**
                     * The em and ex units are relative to the font-size of the current element,
                     * however if the font-size is set using non-pixel units then we get that value
                     * rather than a pixel conversion. To get around this, we keep a floating element
                     * with width:1em which we insert into the target element and then read its offsetWidth.
                     * But if the font-size *is* specified in pixels, then we use that directly to avoid
                     * the expensive DOM manipulation.
                     * @param el
                     */
                    getEmPixels: function( el ) {
                        var fs = el.currentStyle.fontSize,
                            tester, s, px;

                        if( fs.indexOf( 'px' ) > 0 ) {
                            return parseFloat( fs );
                        } else {
                            tester = this._tester;
                            if( !tester ) {
                                tester = this._tester = el.document.createElement( 'length-calc' );
                                s = tester.style;
                                s.width = '1em';
                                s.position = 'absolute';
                                s.top = s.left = -9999;
                                s.visibility = 'hidden';
                            }
                            el.appendChild( tester );
                            px = tester.offsetWidth;
                            el.removeChild( tester );
                            return px;
                        }
                    }
                };

                Length.conversions = (function() {
                    var units = [ 'mm', 'cm', 'in', 'pt', 'pc' ],
                        vals = {},
                        parent = element.parentNode,
                        i = 0, len = units.length, unit, el, s;
                    for( ; i < len; i++ ) {
                        unit = units[i];
                        el = element.document.createElement( 'length-calc' );
                        s = el.style;
                        s.position = 'absolute';
                        s.top = s.left = -9999;
                        s.width = '100' + unit;
                        parent.appendChild( el );
                        vals[ unit ] = el.offsetWidth / 100;
                        parent.removeChild( el );
                    }
                    return vals;
                })();

                return Length;
            } )();


            /**
             * Abstraction for colors. Allows detection of rgba values.
             * @param el
             */
            PIE.Color = (function() {
                function Color( val ) {
                    this.val = val;
                }
                Color.rgbaRE = /\s*rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d+|\d*\.\d+)\s*\)\s*/;
                Color.prototype = {
                    parse: function() {
                        if( !this._color ) {
                            var v = this.val,
                                m = v.match( Color.rgbaRE );
                            if( m ) {
                                this._color = 'rgb(' + m[1] + ',' + m[2] + ',' + m[3] + ')';
                                this._alpha = parseFloat( m[4] );
                            } else {
                                this._color = v;
                                this._alpha = 1;
                            }
                        }
                    },
                    value: function() {
                        this.parse();
                        return this._color;
                    },
                    alpha: function() {
                        this.parse();
                        return this._alpha;
                    }
                };
                return Color;
            })();


            PIE.styleBase = {
                colorRE: /(#[0-9A-Fa-f]{6}|#[0-9A-Fa-f]{3})|rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})(\s*,\s*(\d+|\d*\.\d+))?\s*\)|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|purple|red|silver|teal|white|yellow/,
                lengthRE: /[\-\+]?0|[\-\+]?\d*\.?\d*(px|em|ex|mm|cm|in|pt|pc)/,
                percentRE: /[\-\+]?0|[\-\+]?\d+\.?\d*%/,
                angleRE: /0|\-?\d+(deg|rad|grad)/,
                urlRE: /^url\(\s*['"]?([^\s\)"]*)['"]?\s*\)$/,

                getProps: function() {
                    if( this.changed() ) {
                        this._props = this.parseCss( this._css = this.getCss() );
                    }
                    return this._props;
                },

                getCss: function() {
                    return this.element.style[ this.styleProperty ] ||
                           this.element.currentStyle.getAttribute( this.cssProperty );
                },

                isActive: function() {
                    return !!this.getProps();
                },

                changed: function() {
                    return this._css !== this.getCss();
                }
            };



            PIE.BackgroundStyleInfo = function( el ) {
                this.element = el;
            };
            PIE.merge( PIE.BackgroundStyleInfo.prototype, PIE.styleBase, {

                cssProperty: PIE.CSS_PREFIX + 'background',
                styleProperty: PIE.STYLE_PREFIX + 'Background',

                /*
                [<point> || <angle>,]? <stop>, <stop> [, <stop>]*
                point =
                angle = 0 | <number>deg | <number>rad | <number>grad
                stop = <color> [ <percentage> | <length> ]
                */

                /*parseRE: new RegExp(
                    '^\\s*((P\\s+A)|(A\\s+P)\\s*,\\s*)?(S)\\s*,\\s*(S)((\\s*,\\s*(S))*)?\\s*$'
                        .replace( /P/g, '(top|bottom|right|left)' )
                ),*/

                bgPosRE: / /,
                angleRE: / /,
                stopRE: / /,

                bgLayerRE: / /,

                /**
                 * For background styles, we support the -pie-background property but fall back to the standard
                 * backround* properties.  The reason we have to use the prefixed version is that IE natively
                 * parses the standard properties and if it sees something it doesn't know how to parse, for example
                 * multiple values or gradient definitions, it will throw that away and not make it available through
                 * currentStyle.
                 *
                 * Format of return object:
                 * {
                 *     color: 'red',
                 *     images: [
                 *         {
                 *             type: 'image',
                 *             url: 'image.png',
                 *             repeat: 'no-repeat',
                 *             position: {
                 *                 x: new PIE.Length( '50%' ),
                 *                 y: new PIE.Length( '50%' )
                 *             }
                 *         },
                 *         {
                 *             type: 'linear-gradient',
                 *             position: {
                 *                 x: new PIE.Length( '50%' ),
                 *                 y: new PIE.Length( '50%' )
                 *             },
                 *             angle: 45,
                 *             stops: [
                 *                 { color: 'blue', distance: new Length( '0' ) },
                 *                 { color: 'blue', distance: new Length( '100%' ) }
                 *             ]
                 *         }
                 *     ]
                 * }
                 * @param css
                 */
                parseCss: function( css ) {
                    var el = this.element,
                        cs = el.currentStyle,
                        rs = el.runtimeStyle,
                        posX, posY,
                        rsImage, rsColor,
                        layer, i, len, parenCount,
                        props = null;

                    // If the CSS3-specific -pie-background property is present, parse it
                    if( this.getCss3() ) {
                        // Split the string into layer parts. Can't just use .split() because commas may also
                        // appear within nested values (e.g. gradients); instead walk through the string tracking
                        // the levels of parentheses and looking for commas at the top level.
                        parenCount = 0;
                        for( i = 0; i < len; i++ ) {
                            switch( css.charAt( i ) ) {
                                case '(':
                                    parenCount++;
                                    break;
                                case ')':
                                    parenCount--;
                                    break;
                                case ',':
                                    if( parenCount === 0 ) {
                                        layer = css.substring( 0, i );
                                        css = css.substring( i );
                                        i = 0;

                                        // Now we have a layer part and can parse it into values
                                    }
                            }
                        }

                        /* XXX TESTING
                        return {
                            color: '#EEE',
                            images: [
                                {
                                    url: 'border.png',
                                    repeat: 'no-repeat',
                                    position: {
                                        x: new PIE.Length( '0' ),
                                        y: new PIE.Length( '0' )
                                    }
                                },
                                {
                                    url: 'border.png',
                                    repeat: 'no-repeat',
                                    position: {
                                        x: new PIE.Length( '100%' ),
                                        y: new PIE.Length( '0' )
                                    }
                                },
                                {
                                    url: 'border.png',
                                    repeat: 'no-repeat',
                                    position: {
                                        x: new PIE.Length( '100%' ),
                                        y: new PIE.Length( '100%' )
                                    }
                                },
                                {
                                    url: 'border.png',
                                    repeat: 'no-repeat',
                                    position: {
                                        x: new PIE.Length( '0' ),
                                        y: new PIE.Length( '100%' )
                                    }
                                }
                            ]
                        }*/
                    }

                    // Otherwise, use the standard background properties; let IE give us the values rather than parsing them
                    else {
                        this.withActualBg( function() {
                            posX = cs.backgroundPositionX;
                            posY = cs.backgroundPositionY;
                            posX = new PIE.Length( posX === 'left' ? '0' : posX === 'center' ? '50%' : posX === 'right' ? '100%' : posX );
                            posY = new PIE.Length( posY === 'top' ? '0' : posY === 'center' ? '50%' : posY === 'bottom' ? '100%' : posY );

                            props = {
                                color: new PIE.Color( cs.backgroundColor ),
                                images: [ {
                                    url: cs.backgroundImage.replace( this.urlRE, "$1" ),
                                    repeat: cs.backgroundRepeat,
                                    position: {
                                        x: posX,
                                        y: posY
                                    }
                                } ]
                            };
                        } );
                    }

                    return props;
                },

                /**
                 * Execute a function with the actual background styles (not overridden with runtimeStyle
                 * properties set by the renderers) available via currentStyle.
                 * @param fn
                 */
                withActualBg: function( fn ) {
                    var rs = this.element.runtimeStyle,
                        rsImage = rs.backgroundImage,
                        rsColor = rs.backgroundColor,
                        ret;

                    rs.backgroundImage = rs.backgroundColor = '';

                    ret = fn.call( this );

                    rs.backgroundImage = rsImage;
                    rs.backgroundColor = rsColor;

                    return ret;
                },

                getCss: function() {
                    var cs = this.element.currentStyle;
                    return this.getCss3() ||
                           this.withActualBg( function() {
                               return cs.backgroundColor + ' ' + cs.backgroundImage + ' ' + cs.backgroundRepeat + ' ' +
                               cs.backgroundPositionX + ' ' + cs.backgroundPositionY;
                           } );
                },

                getCss3: function() {
                    var el = this.element;
                    return el.style[ this.styleProperty ] || el.currentStyle.getAttribute( this.cssProperty );
                },

                /**
                 * The isActive logic is slightly different, because getProps() always returns an object
                 * even if it is just falling back to the native background properties.  But we only want
                 * to report is as being "active" if the -pie-background override property is present and
                 * parses successfully.
                 */
                isActive: function() {
                    return this.getCss3() && !!this.getProps();
                }

            } );



            PIE.BorderStyleInfo = function( el ) {
                this.element = el;
            };
            PIE.merge( PIE.BorderStyleInfo.prototype, PIE.styleBase, {

                sides: [ 'Top', 'Right', 'Bottom', 'Left' ],
                namedWidths: {
                    thin: '1px',
                    medium: '3px',
                    thick: '5px'
                },

                parseCss: function( css ) {
                    var w = {},
                        s = {},
                        c = {},
                        el = this.element,
                        cs = el.currentStyle,
                        rs = el.runtimeStyle,
                        rtColor = rs.borderColor,
                        i = 0,
                        active = false,
                        colorsSame = true, stylesSame = true, widthsSame = true,
                        style, color, width, lastStyle, lastColor, lastWidth, side, ltr;

                    rs.borderColor = '';
                    for( ; i < 4; i++ ) {
                        side = this.sides[ i ];
                        ltr = side.charAt(0).toLowerCase();
                        style = s[ ltr ] = cs[ 'border' + side + 'Style' ];
                        color = cs[ 'border' + side + 'Color' ];
                        width = cs[ 'border' + side + 'Width' ];

                        if( i > 0 ) {
                            if( style !== lastStyle ) { stylesSame = false; }
                            if( color !== lastColor ) { colorsSame = false; }
                            if( width !== lastWidth ) { widthsSame = false; }
                        }
                        lastStyle = style;
                        lastColor = color;
                        lastWidth = width;

                        c[ ltr ] = new PIE.Color( color );

                        width = w[ ltr ] = new PIE.Length( s[ ltr ] === 'none' ? '0' : ( this.namedWidths[ width ] || width ) );
                        if( s[ ltr ] !== 'none' || width.pixels( this.element ) > 0 ) {
                            active = true;
                        }
                    }
                    rs.borderColor = rtColor;

                    return active ? { 
                        widths: w,
                        styles: s,
                        colors: c,
                        widthsSame: widthsSame,
                        colorsSame: colorsSame,
                        stylesSame: stylesSame
                    } : null;
                },

                getCss: function() {
                    var el = this.element,
                        cs = el.currentStyle,
                        rs = el.runtimeStyle,
                        rtColor = rs.borderColor,
                        css;

                    rs.borderColor = '';
                    css = cs.borderWidth + '|' + cs.borderStyle + '|' + cs.borderColor;
                    rs.borderColor = rtColor;
                    return css;
                }

            } );




            PIE.BorderRadiusStyleInfo = function( el ) {
                this.element = el;
            };
            PIE.merge( PIE.BorderRadiusStyleInfo.prototype, PIE.styleBase, {

                cssProperty: 'border-radius',
                styleProperty: 'borderRadius',

                parseRE: new RegExp(
                    '^G(\\/G)?$'.replace( /G/g, '\\s*(L)(\\s+(L))?(\\s+(L))?(\\s+(L))?\\s*'.replace( /L/g, PIE.styleBase.lengthRE.source + '|' + PIE.styleBase.percentRE.source ) )
                ),

                parseCss: function( css ) {
                    var p = null, x, y, c,
                        hasNonZero = false,
                        m = css && css.match( this.parseRE );

                    function len( v ) {
                        return new PIE.Length( v );
                    }

                    if( m ) {
                        x = {
                            tl: len( m[1] ),
                            tr: len( m[4] || m[1] ),
                            br: len( m[7] || m[1] ),
                            bl: len( m[10] || m[4] || m[1] )
                        };
                        for( c in x ) {
                            if( x.hasOwnProperty( c ) && x[c].getNumber() !== 0 ) {
                                hasNonZero = true;
                            }
                        }

                        if( m[12] ) {
                            y = {
                                tl: len( m[13] ),
                                tr: len( m[16] || m[13] ),
                                br: len( m[19] || m[13] ),
                                bl: len( m[22] || m[16] || m[13] )
                            };
                            for( c in y ) {
                                if( y.hasOwnProperty( c ) && y[c].getNumber() !== 0 ) {
                                    hasNonZero = true;
                                }
                            }
                        } else {
                            y = x;
                        }

                        // Treat all-zero values the same as no value
                        if( hasNonZero ) {
                            p = { x: x, y : y };
                        }
                    }

                    return p;
                }
            } );



            PIE.BorderImageStyleInfo = function( el ) {
                this.element = el;
            };
            PIE.merge( PIE.BorderImageStyleInfo.prototype, PIE.styleBase, {

                cssProperty: PIE.CSS_PREFIX + 'border-image',
                styleProperty: PIE.STYLE_PREFIX + 'BorderImage',

                //TODO this needs to be reworked to allow the components to appear in arbitrary order
                parseRE: new RegExp(
                    '^\\s*url\\(\\s*([^\\s\\)]+)\\s*\\)\\s+N(\\s+N)?(\\s+N)?(\\s+N)?(\\s*\\/\\s*L(\\s+L)?(\\s+L)?(\\s+L)?)?RR\\s*$'
                            .replace( /N/g, '(\\d+|' + PIE.styleBase.percentRE.source + ')' )
                            .replace( /L/g, PIE.styleBase.lengthRE.source )
                            .replace( /R/g, '(\\s+(stretch|round|repeat))?' )
                ),

                parseCss: function( css ) {
                    var cs = this.element.currentStyle,
                        p = null,
                        Length = PIE.Length,
                        m = css && css.match( this.parseRE );

                    if( m ) {
                        p = {
                            src: m[1],

                            slice: {
                                t: parseInt( m[2], 10 ),
                                r: parseInt( m[4] || m[2], 10 ),
                                b: parseInt( m[6] || m[2], 10 ),
                                l: parseInt( m[8] || m[4] || m[2], 10 )
                            },

                            width: m[9] ? {
                                t: new Length( m[10] ),
                                r: new Length( m[12] || m[10] ),
                                b: new Length( m[14] || m[10] ),
                                l: new Length( m[16] || m[12] || m[10] )
                            } : {
                                t: new Length( cs.borderTopWidth ),
                                r: new Length( cs.borderRightWidth ),
                                b: new Length( cs.borderBottomWidth ),
                                l: new Length( cs.borderLeftWidth )
                            },

                            repeat: {
                                h: m[18] || 'stretch',
                                v: m[20] || m[18] || 'stretch'
                            }
                        };
                    }

                    return p;
                }
            } );


            PIE.BoxShadowStyleInfo = function( el ) {
                this.element = el;
            };
            PIE.merge( PIE.BoxShadowStyleInfo.prototype, PIE.styleBase, {

                cssProperty: PIE.CSS_PREFIX + 'box-shadow',
                styleProperty: PIE.STYLE_PREFIX + 'BoxShadow',

                noneRE: /^\s*none\s*$/,
                insetRE: /(inset)/,
                lengthsRE: new RegExp( '\\s*(L)\\s+(L)(\\s+(L))?(\\s+(L))?\\s*'.replace( /L/g, PIE.styleBase.lengthRE.source ) ),

                parseCss: function( css ) {
                    var p = null, m,
                        Length = PIE.Length;

                    if( css && !this.noneRE.test( css ) ) {
                        p = {};

                        // check for inset keyword
                        if( this.insetRE.test( css ) ) {
                            css = css.replace( this.insetRE, '' );
                            p.inset = true;
                        }

                        // get the color
                        m = css.match( this.colorRE );
                        if( m ) {
                            css = css.replace( this.colorRE, '' );
                            p.color = new PIE.Color( m[0] );
                        } else {
                            p.color = new PIE.Color( this.element.currentStyle.color );
                        }

                        // all that's left should be lengths; map them to xOffset/yOffset/blurRadius/spreadRadius
                        m = css.match( this.lengthsRE );
                        if( m ) {
                            p.xOffset = new Length( m[1] );
                            p.yOffset = new Length( m[3] );
                            p.blur = new Length( m[6] || '0' );
                            p.spread = new Length( m[9] || '0' );
                        } else {
                            // Something unknown was present; give up.
                            p = null;
                        }
                    }

                    return p;
                }
            } );




            PIE.rendererBase = {

                needsUpdate: function() {
                    return false;
                },

                updateProps: function() {
                },

                updatePos: function() {
                },

                updateSize: function() {
                },

                updateVis: function() {
                },

                getShape: function( name, subElName ) {
                    var shapes = this._shapes || ( this._shapes = {} ),
                        shape = shapes[ name ],
                        s;

                    if( !shape ) {
                        shape = shapes[ name ] = PIE.createVmlElement( 'shape' );
                        if( subElName ) {
                            shape.appendChild( shape[ subElName ] = PIE.createVmlElement( subElName ) );
                        }
                        this.getBox().appendChild( shape );
                        s = shape.style;
                        s.position = 'absolute';
                        s.left = s.top = 0;
                        s.behavior = 'url(#default#VML)';
                    }
                    return shape;
                },

                getRadiiPixels: function( radii ) {
                    var el = this.element,
                        w = el.offsetWidth,
                        h = el.offsetHeight,
                        tlX, tlY, trX, trY, brX, brY, blX, blY, f;

                    tlX = radii.x.tl.pixels( el, w );
                    tlY = radii.y.tl.pixels( el, h );
                    trX = radii.x.tr.pixels( el, w );
                    trY = radii.y.tr.pixels( el, h );
                    brX = radii.x.br.pixels( el, w );
                    brY = radii.y.br.pixels( el, h );
                    blX = radii.x.bl.pixels( el, w );
                    blY = radii.y.bl.pixels( el, h );

                    // If any corner ellipses overlap, reduce them all by the appropriate factor. This formula
                    // is taken straight from the CSS3 Backgrounds and Borders spec.
                    f = Math.min(
                        w / ( tlX + trX ),
                        h / ( trY + brY ),
                        w / ( blX + brX ),
                        h / ( tlY + blY )
                    );
                    if( f < 1 ) {
                        tlX *= f;
                        tlY *= f;
                        trX *= f;
                        trY *= f;
                        brX *= f;
                        brY *= f;
                        blX *= f;
                        blY *= f;
                    }

                    return {
                        x: {
                            tl: tlX,
                            tr: trX,
                            br: brX,
                            bl: blX
                        },
                        y: {
                            tl: tlY,
                            tr: trY,
                            br: brY,
                            bl: blY
                        }
                    }
                },

                getBoxPath: function( shrink ) {
                    var r, instructions, values, str = '', i,
                        el = this.element,
                        w = el.offsetWidth - 1,
                        h = el.offsetHeight - 1,
                        radInfo = this.styleInfos.borderRadius,
                        floor = Math.floor, ceil = Math.ceil,
                        deg = 65535,
                        tlX, tlY, trX, trY, brX, brY, blX, blY;

                    shrink = floor( shrink || 0 );

                    if( radInfo.isActive() ) {
                        r = this.getRadiiPixels( radInfo.getProps() );

                        tlX = r.x.tl;
                        tlY = r.y.tl;
                        trX = r.x.tr;
                        trY = r.y.tr;
                        brX = r.x.br;
                        brY = r.y.br;
                        blX = r.x.bl;
                        blY = r.y.bl;

                        instructions = [ 'm', 'qy', 'l', 'qx', 'l', 'qy', 'l', 'qx' ];
                        values = [
                            shrink + ',' + floor(tlY),
                            floor(tlX) + ',' + shrink,
                            ceil(w - trX) + ',' + shrink,
                            ( w - shrink ) + ',' + floor(trY),
                            ( w - shrink ) + ',' + ceil(h - brY),
                            ceil(w - brX) + ',' + ( h - shrink ),
                            floor(blX) + ',' + ( h - shrink ),
                            shrink + ',' + ceil(h - blY)
                        ];

                        for ( i = 0; i < 8; i++ ) {
                            str += instructions[i] + values[i];
                        }
                        str += ' x e';
                    } else {
                        // simplified path for non-rounded box
                        str = 'm' + shrink + ',' + shrink +
                              'l' + ( w - shrink ) + ',' + shrink +
                              'l' + ( w - shrink ) + ',' + ( h - shrink ) +
                              'l' + shrink + ',' + ( h - shrink ) +
                              'xe';
                    }
                    return str;
                }
            };




            PIE.RootRenderer = function( el, styleInfos ) {
                this.element = el;
                this.styleInfos = styleInfos;
            };
            PIE.merge( PIE.RootRenderer.prototype, PIE.rendererBase, {

                isActive: function() {
                    var infos = this.styleInfos;
                    for( var i in infos ) {
                        if( infos.hasOwnProperty( i ) && infos[ i ].isActive() ) {
                            return true;
                        }
                    }
                    return false;
                },

                updateVis: function() {
                    if( this.isActive() ) {
                        var cs = this.element.currentStyle;
                        this.getBox().style.display = ( cs.visibility === 'hidden' || cs.display === 'none' ) ? 'none' : '';
                    }
                },

                updatePos: function() {
                    if( this.isActive() ) {
                        var el = this.element,
                            par = el,
                            docEl,
                            elRect, parRect,
                            s = this.getBox().style,
                            x = 0, y = 0;

                        // Get the element's offsets from its nearest positioned ancestor. Uses
                        // getBoundingClientRect for accuracy and speed.
                        do {
                            par = par.offsetParent;
                        } while( par && par.currentStyle.position === 'static' );
                        elRect = el.getBoundingClientRect();
                        if( par ) {
                            parRect = par.getBoundingClientRect();
                            x = elRect.left - parRect.left;
                            y = elRect.top - parRect.top;
                        } else {
                            docEl = el.document.documentElement;
                            x = elRect.left + docEl.scrollLeft - docEl.clientLeft;
                            y = elRect.top + docEl.scrollTop - docEl.clientTop;
                        }

                        s.left = x;
                        s.top = y;
                        s.zIndex = el.currentStyle.position === 'static' ? -1 : el.currentStyle.zIndex;
                    }
                },

                updateSize: function() {
                    if( this.isActive() ) {
                        var el = this.element,
                            s = this.getBox().style,
                            i, len;

                        s.width = el.offsetWidth;
                        s.height = el.offsetHeight;
                    }
                },

                getBox: function() {
                    var box = this._box, el, s;
                    if( !box ) {
                        el = this.element;
                        box = this._box = el.document.createElement( 'css3-container' );
                        s = box.style;

                        s.position = 'absolute';

                        el.parentNode.insertBefore( box, el );
                    }
                    return box;
                },

                destroy: function() {
                    var box = this._box;
                    if( box && box.parentNode ) {
                        box.parentNode.removeChild( box );
                    }
                    delete this._box;
                }

            } );



            PIE.BackgroundAndBorderRenderer = function( el, styleInfos, parent ) {
                this.element = el;
                this.styleInfos = styleInfos;
                this.parent = parent;
            };
            PIE.merge( PIE.BackgroundAndBorderRenderer.prototype, PIE.rendererBase, {

                zIndex: 200,

                needsUpdate: function() {
                    var si = this.styleInfos;
                    return si.border.changed() || si.background.changed();
                },

                isActive: function() {
                    var si = this.styleInfos;
                    return si.borderImage.isActive() ||
                           si.borderRadius.isActive() ||
                           si.background.isActive() ||
                           ( si.boxShadow.isActive() && si.boxShadow.getProps().inset );
                },

                updateSize: function() {
                    if( this.isActive() ) {
                        this.draw();
                    }
                },

                updateProps: function() {
                    this.destroy();
                    if( this.isActive() ) {
                        this.draw();
                    }
                },

                draw: function() {
                    this.drawBgColor();
                    this.drawBgImages();
                    this.drawBorder();
                },

                drawBgColor: function() {
                    var props = this.styleInfos.background.getProps(),
                        color = props && props.color && props.color.value(),
                        cont, el, shape, w, h, s, alpha;

                    if( color && color !== 'transparent' ) {
                        cont = this.getBox();
                        el = this.element;
                        shape = this.getShape( 'bgColor', 'fill' );
                        w = el.offsetWidth;
                        h = el.offsetHeight;
                        shape.stroked = false;
                        shape.coordsize = w + ',' + h;
                        shape.path = this.getBoxPath();
                        s = shape.style;
                        s.width = w;
                        s.height = h;
                        s.zIndex = 1;
                        shape.fill.color = color;

                        alpha = props.color.alpha();
                        if( alpha < 1 ) {
                            shape.fill.opacity = alpha;
                        }

                        el.runtimeStyle.backgroundColor = 'transparent';
                    }
                },

                drawBgImages: function() {
                    var props = this.styleInfos.background.getProps(),
                        images = props && props.images,
                        img, cont, el, shape, w, h, s, i;

                    if( images ) {
                        i = images.length;
                        while( i-- ) {
                            img = images[i].url;
                            if( img && img !== 'none' ) {
                                el = this.element,
                                shape = this.getShape( 'bgImage' + i, 'fill' ),
                                w = el.offsetWidth,
                                h = el.offsetHeight,
                                s, img;

                                shape.stroked = false;
                                shape.fill.type = 'tile';
                                shape.fillcolor = 'none';
                                shape.coordsize = w + ',' + h;
                                shape.path = this.getBoxPath();
                                s = shape.style;
                                s.width = w;
                                s.height = h;
                                s.zIndex = 2;
                                shape.fill.src = img;
                                this.positionBgImage( shape, i );

                                el.runtimeStyle.backgroundImage = 'none';
                            }
                        }
                    }
                },

                positionBgImage: function( shape, index ) {
                    PIE.withImageSize( shape.fill.src, function( size ) {
                        var fill = shape.fill,
                            el = this.element,
                            elW = el.offsetWidth,
                            elH = el.offsetHeight,
                            cs = el.currentStyle,
                            si = this.styleInfos,
                            bg = si.background.getProps().images[ index ],
                            border = si.border.getProps(),
                            bwT = border ? border.widths.t.pixels( el ) : 0,
                            bwR = border ? border.widths.r.pixels( el ) : 0,
                            bwB = border ? border.widths.b.pixels( el ) : 0,
                            bwL = border ? border.widths.l.pixels( el ) : 0,
                            repeat = bg.repeat,
                            pxX, pxY,
                            clipT = 0, clipR = elW, clipB = elH, clipL = 0;

                        // Positioning - find the pixel offset from the top/left and convert to a ratio
                        pxX = bg.position.x.pixels( el, elW - size.w - bwL - bwR ) + bwL;
                        pxY = bg.position.y.pixels( el, elH - size.h - bwT - bwB ) + bwT;
                        fill.position = ( pxX / elW ) + ',' + ( pxY / elH );

                        // Repeating - clip the image shape
                        if( repeat !== 'repeat' ) {
                            if( repeat === 'repeat-x' || repeat === 'no-repeat' ) {
                                clipT = pxY;
                                clipB = pxY + size.h;
                            }
                            if( repeat === 'repeat-y' || repeat === 'no-repeat' ) {
                                clipL = pxX;
                                clipR = pxX + size.w;
                            }
                            shape.style.clip = 'rect(' + clipT + 'px,' + clipR + 'px,' + clipB + 'px,' + clipL + 'px)';
                        }
                    }, this );
                },

                drawBorder: function() {
                    var cont = this.getBox(),
                        el = this.element,
                        cs = el.currentStyle,
                        w = el.offsetWidth,
                        h = el.offsetHeight,
                        props = this.styleInfos.border.getProps(),
                        styles, colors, widths,
                        side, shape, stroke, bColor, bWidth, bStyle, s;

                    if( props ) {
                        styles = props.styles;
                        colors = props.colors;
                        widths = props.widths;

                        this.hideBorder();

                        var segments = this.getBorderSegments();
                        for( var i=0; i<segments.length; i++) {
                            var seg = segments[i];
                            shape = this.getShape( 'borderPiece' + i, seg.stroke ? 'stroke' : 'fill' );
                            shape.coordsize = w + ',' + h;
                            shape.path = seg.path;
                            s = shape.style;
                            s.width = w;
                            s.height = h;
                            s.zIndex = 3;

                            shape.filled = !!seg.fill;
                            shape.stroked = !!seg.stroke;
                            if( seg.stroke ) {
                                stroke = shape.stroke;
                                stroke.weight = seg.weight + 'px';
                                stroke.color = seg.color.value();
                                stroke.dashstyle = seg.stroke === 'dashed' ? '2 2' : seg.stroke === 'dotted' ? '1 1' : 'solid';
                                stroke.linestyle = seg.stroke === 'double' && seg.weight > 2 ? 'ThinThin' : 'Single';
                            } else {
                                shape.fill.color = seg.fill.value();
                            }
                        }
                    }
                },

                /**
                 * Hide the actual border of the element. In IE7 and up we can just set its color to transparent;
                 * however IE6 does not support transparent borders so we have to get tricky with it.
                 */
                hideBorder: function() {
                    var el = this.element;
                    if( PIE.isIE6 ) {
                        // Wrap all the element's children in a custom element, set the element to visiblity:hidden,
                        // and set the wrapper element to visiblity:visible. This hides the outer element's decorations
                        // (background and border) but displays all the contents.
                        // TODO find a better way to do this that doesn't mess up the DOM parent-child relationship,
                        // as this can interfere with other author scripts which add/modify/delete children. Look into
                        // using a compositor filter which masks the border.
                        if( el.childNodes.length !== 1 || el.firstChild.tagName !== 'ie6-mask' ) {
                            var cont = this.element.document.createElement( 'ie6-mask' );
                            cont.style.visibility = 'visible';
                            cont.style.zoom = 1;
                            while( el.firstChild ) {
                                cont.appendChild( el.firstChild );
                            }
                            el.appendChild( cont );
                            el.runtimeStyle.visibility = 'hidden';
                        }
                    } else {
                        el.runtimeStyle.borderColor = 'transparent';
                    }
                },

                getBorderSegments: function() {
                    var el = this.element,
                        elW, elH,
                        borderInfo = this.styleInfos.border,
                        segments = [],
                        deg = 65535,
                        floor, ceil, wT, wR, wB, wL,
                        borderProps, radiusInfo, radii, widths, styles, colors;

                    if( borderInfo.isActive() ) {
                        borderProps = borderInfo.getProps();

                        widths = borderProps.widths;
                        styles = borderProps.styles;
                        colors = borderProps.colors;

                        if( borderProps.widthsSame && borderProps.stylesSame && borderProps.colorsSame ) {
                            // shortcut for identical border on all sides - only need 1 stroked shape
                            wT = widths.t.pixels( el );
                            segments.push( {
                                path: this.getBoxPath( wT / 2 ),
                                stroke: styles.t,
                                color: colors.t,
                                weight: wT
                            } );
                        }
                        else {
                            elW = el.offsetWidth - 1;
                            elH = el.offsetHeight - 1;

                            wT = widths.t.pixels( el );
                            wR = widths.r.pixels( el );
                            wB = widths.b.pixels( el );
                            wL = widths.l.pixels( el );
                            var pxWidths = {
                                t: wT,
                                r: wR,
                                b: wB,
                                l: wL
                            };

                            radiusInfo = this.styleInfos.borderRadius;
                            if( radiusInfo.isActive() ) {
                                radii = this.getRadiiPixels( radiusInfo.getProps() );
                            }

                            floor = Math.floor;
                            ceil = Math.ceil;

                            function curve( corner, shrinkX, shrinkY, startAngle, ccw ) {
                                var rx = radii.x[ corner ],
                                    ry = radii.y[ corner ],
                                    deg = 65535,
                                    isRight = corner.charAt( 1 ) === 'r',
                                    isBottom = corner.charAt( 0 ) === 'b';
                                return ( rx > 0 && ry > 0 ) ?
                                            ( isRight ? ceil( elW - rx ) : floor( rx ) ) + ',' + // center x
                                            ( isBottom ? ceil( elH - ry ) : floor( ry ) ) + ',' + // center y
                                            ( floor( rx ) - shrinkX ) + ',' + // width
                                            ( floor( ry ) - shrinkY ) + ',' + // height
                                            ( startAngle * deg ) + ',' + // start angle
                                            ( 45 * deg * ( ccw ? 1 : -1 ) ) // angle change
                                        : '';
                            }


                            function addSide( side, sideBefore, sideAfter, cornerBefore, cornerAfter, baseAngle ) {
                                var vert = side === 'l' || side === 'r',
                                    beforeX, beforeY, afterX, afterY;

                                if( pxWidths[ side ] > 0 && styles[ side ] !== 'none' ) {
                                    beforeX = pxWidths[ vert ? side : sideBefore ];
                                    beforeY = pxWidths[ vert ? sideBefore : side ];
                                    afterX = pxWidths[ vert ? side : sideAfter ];
                                    afterY = pxWidths[ vert ? sideAfter : side ];
                                    
                                    if( styles[ side ] === 'dashed' || styles[ side ] === 'dotted' ) {
                                        segments.push( {
                                            path: 'al' + curve( cornerBefore, beforeX, beforeY, baseAngle + 45, 0 ) +
                                                  'ae' + curve( cornerBefore, 0, 0, baseAngle, 1 ),
                                            fill: colors[ side ]
                                        } );
                                        segments.push( {
                                            path: (
                                                side === 't' ?
                                                    'm' + floor( radii.x.tl ) + ',' + ceil( wT/2 ) +
                                                    'l' + ceil( elW - radii.x.tr ) + ',' + ceil( wT/2 ) :
                                                side === 'r' ?
                                                    'm' + ceil( elW - wR/2 ) + ',' + floor( radii.y.tr ) +
                                                    'l' + ceil( elW - wR/2 ) + ',' + ceil( elH - radii.y.br ) :
                                                side === 'b' ?
                                                    'm' + ceil( elW - radii.x.br ) + ',' + floor( elH - wB/2 ) +
                                                    'l' + floor( radii.x.bl ) + ',' + floor( elH - wB/2 ) :
                                                // side === 'l'
                                                    'm' + floor( wL/2 ) + ',' + ceil( elH - radii.y.bl ) +
                                                    'l' + floor( wL/2 ) + ',' + floor( radii.y.tl )
                                            ),
                                            stroke: styles[ side ],
                                            weight: pxWidths[ side ],
                                            color: colors[ side ]
                                        } );
                                        segments.push( {
                                            path: 'al' + curve( cornerAfter, afterX, afterY, baseAngle, 0 ) +
                                                  'ae' + curve( cornerAfter, 0, 0, baseAngle - 45, 1 ),
                                            fill: colors[ side ]
                                        } );
                                    }
                                    else {
                                        segments.push( {
                                            path: 'al' + curve( cornerBefore, beforeX, beforeY, baseAngle + 45, 0 ) +
                                                  'ae' + curve( cornerAfter, afterX, afterY, baseAngle, 0 ) +

                                                  ( styles[ side ] === 'double' && pxWidths[ side ] > 2 ?
                                                          'ae' + curve( cornerAfter, afterX - floor( afterX / 3 ), afterY - floor( afterY / 3 ), baseAngle - 45, 1 ) +
                                                          'ae' + curve( cornerBefore, beforeX - floor( beforeX / 3 ), beforeY - floor( beforeY / 3 ), baseAngle, 1 ) +
                                                          'x al' + curve( cornerBefore, floor( beforeX / 3 ), floor( beforeY / 3 ), baseAngle + 45, 0 ) +
                                                          'ae' + curve( cornerAfter, floor( afterX / 3 ), floor( afterY / 3 ), baseAngle, 0 )
                                                      : '' ) +

                                                  'ae' + curve( cornerAfter, 0, 0, baseAngle - 45, 1 ) +
                                                  'ae' + curve( cornerBefore, 0, 0, baseAngle, 1 ),
                                            fill: colors[ side ]
                                        } );
                                    }
                                }
                            }

                            addSide( 't', 'l', 'r', 'tl', 'tr', 90 );
                            addSide( 'r', 't', 'b', 'tr', 'br', 0 );
                            addSide( 'b', 'r', 'l', 'br', 'bl', -90 );
                            addSide( 'l', 'b', 't', 'bl', 'tl', -180 );
                        }
                    }

                    return segments;
                },

                getBox: function() {
                    var box = this._box,
                        infos = this.styleInfos,
                        s;

                    if( !box ) {
                        box = this._box = this.element.document.createElement( 'bg-and-border' );
                        s = box.style;
                        s.position = 'absolute';
                        s.zIndex = this.zIndex;
                        this.parent.getBox().appendChild( box );
                    }

                    return box;
                },

                destroy: function() {
                    var box = this._box;
                    if( box && box.parentNode ) {
                        box.parentNode.removeChild( box );
                    }
                    delete this._box;
                    delete this._shapes;
                }

            } );



            PIE.BorderImageRenderer = function( el, styleInfos, parent ) {
                this.element = el;
                this.styleInfos = styleInfos;
                this.parent = parent;
            };
            PIE.merge( PIE.BorderImageRenderer.prototype, PIE.rendererBase, {

                zIndex: 400,
                pieceNames: [ 't', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl', 'c' ],

                needsUpdate: function() {
                    var si = this.styleInfos;
                    return si.borderImage.changed() || si.border.changed();
                },

                isActive: function() {
                    return this.styleInfos.borderImage.isActive();
                },

                updateSize: function() {
                    if( this.isActive() ) {
                        var props = this.styleInfos.borderImage.getProps(),
                            box = this.getBox(), //make sure pieces are created
                            el = this.element,
                            p = this.pieces;

                        PIE.withImageSize( props.src, function( imgSize ) {
                            var w = el.offsetWidth,
                                h = el.offsetHeight,
                                z = el.currentStyle.zIndex,

                                t = p.t.style,
                                tr = p.tr.style,
                                r = p.r.style,
                                br = p.br.style,
                                b = p.b.style,
                                bl = p.bl.style,
                                l = p.l.style,
                                tl = p.tl.style,
                                c = p.c.style,

                                slices = props.slice,
                                widths = props.width,
                                widthT = widths.t.pixels( el ),
                                widthR = widths.r.pixels( el ),
                                widthB = widths.b.pixels( el ),
                                widthL = widths.l.pixels( el );

                            tl.height = t.height = tr.height = widthT;
                            tl.width = l.width = bl.width = widthL;
                            tr.left = r.left = br.left = w - widthR;
                            tr.width = r.width = br.width = widthR;
                            br.top = b.top = bl.top = h - widthB;
                            br.height = b.height = bl.height = widthB;
                            t.left = b.left = c.left = widthL;
                            t.width = b.width = c.width = w - widthL - widthR;
                            l.top = r.top = c.top = widthT;
                            l.height = r.height = c.height = h - widthT - widthB;


                            // image croppings

                            // corners
                            p.tl.imagedata.cropBottom = p.t.imagedata.cropBottom = p.tr.imagedata.cropBottom = ( imgSize.h - slices.t ) / imgSize.h;
                            p.tl.imagedata.cropRight = p.l.imagedata.cropRight = p.bl.imagedata.cropRight = ( imgSize.w - slices.l ) / imgSize.w;
                            p.bl.imagedata.cropTop = p.b.imagedata.cropTop = p.br.imagedata.cropTop = ( imgSize.h - slices.b ) / imgSize.h;
                            p.tr.imagedata.cropLeft = p.r.imagedata.cropLeft = p.br.imagedata.cropLeft = ( imgSize.w - slices.r ) / imgSize.w;

                            // edges and center
                            if( props.repeat.v === 'stretch' ) {
                                p.l.imagedata.cropTop = p.r.imagedata.cropTop = p.c.imagedata.cropTop = slices.t / imgSize.h;
                                p.l.imagedata.cropBottom = p.r.imagedata.cropBottom = p.c.imagedata.cropBottom = slices.b / imgSize.h;
                            }
                            if( props.repeat.h === 'stretch' ) {
                                p.t.imagedata.cropLeft = p.b.imagedata.cropLeft = p.c.imagedata.cropLeft = slices.l / imgSize.w;
                                p.t.imagedata.cropRight = p.b.imagedata.cropRight = p.c.imagedata.cropRight = slices.r / imgSize.w;
                            }
                        }, this );
                    }
                },

                updateProps: function() {
                    this.destroy();
                    if( this.isActive() ) {
                        this.updateSize();
                    }
                },

                getBox: function() {
                    var box = this._box, s, piece, i,
                        pieceNames = this.pieceNames,
                        len = pieceNames.length;

                    if( !box ) {
                        box = this._box = this.element.document.createElement( 'border-image' );
                        s = box.style;
                        s.position = 'absolute';
                        s.zIndex = this.zIndex;

                        this.pieces = {};

                        for( i = 0; i < len; i++ ) {
                            piece = this.pieces[ pieceNames[i] ] = PIE.createVmlElement( 'rect' );
                            piece.appendChild( PIE.createVmlElement( 'imagedata' ) );
                            s = piece.style;
                            s.behavior = 'url(#default#VML)';
                            s.position = "absolute";
                            s.top = s.left = 0;
                            piece.imagedata.src = this.styleInfos.borderImage.getProps().src;
                            piece.stroked = false;
                            piece.filled = false;
                            box.appendChild( piece );
                        }

                        this.parent.getBox().appendChild( box );
                    }

                    return box;
                },

                destroy: function() {
                    var box = this._box;
                    if( box && box.parentNode ) {
                        box.parentNode.removeChild( box );
                    }
                    delete this._box;
                }

            } );


            PIE.BoxShadowRenderer = function( el, styleInfos, parent ) {
                this.element = el;
                this.styleInfos = styleInfos;
                this.parent = parent;
            };
            PIE.merge( PIE.BoxShadowRenderer.prototype, PIE.rendererBase, {

                outsetZIndex: 100,
                insetZIndex: 300,

                needsUpdate: function() {
                    var si = this.styleInfos;
                    return si.boxShadow.changed() || si.borderRadius.changed();
                },

                isActive: function() {
                    return this.styleInfos.boxShadow.isActive();
                },

                updateSize: function() {
                    if( this.isActive() ) {
                        var box = this.getBox(),
                            shape = box.firstChild,
                            s,
                            el = this.element,
                            bs = this.styleInfos.boxShadow.getProps(),
                            spread = bs.spread.pixels( el ),
                            w = el.offsetWidth,
                            h = el.offsetHeight;

                        if( bs.inset ) {
                            // if inset, the width does not include any element border
                            s = el.currentStyle;
                            w -= ( parseInt( s.borderLeftWidth, 10 ) || 0 ) + ( parseInt( s.borderRightWidth, 10 ) || 0 );
                            h -= ( parseInt( s.borderTopWidth, 10 ) || 0 ) + ( parseInt( s.borderBottomWidth, 10 ) || 0 );

                            // update width of inner element
                            s = box.firstChild.style;
                            s.width = w - spread * 2;
                            s.height = h - spread * 2;
                        } else {
                            w += spread * 2;
                            h += spread * 2;
                        }

                        s = shape.style;
                        s.width = w;
                        s.height = h;

                        shape.coordsize = ( w + 1 ) + ',' + ( h + 1 ); //shrink the rendered shadow by 1 extra pixel
                        shape.path = this.getBoxPath();
                    }
                },

                updateProps: function() {
                    this.destroy();
                    if( this.isActive() ) {
                        this.updateSize();
                    }
                },

                getBox: function() {
                    var box = this._box, s, ss, cs, bs, xOff, yOff, spread, blur, halfBlur, shape, el, filter, alpha;
                    if( !box ) {
                        el = this.element;
                        box = this._box = el.document.createElement( 'box-shadow' );
                        bs = this.styleInfos.boxShadow.getProps();
                        xOff = bs.xOffset.pixels( el );
                        yOff = bs.yOffset.pixels( el );
                        blur = bs.blur.pixels( el );
                        spread = bs.spread.pixels( el );

                        // Adjust the blur value so it's always an even number
                        halfBlur = Math.ceil( blur / 2 );
                        blur = halfBlur * 2;

                        s = box.style;
                        s.position = 'absolute';

                        shape = this.getShape( 'shadow', 'fill' );
                        ss = shape.style;
                        shape.stroked = false;

                        if( bs.inset ) {
                            cs = this.element.currentStyle;
                            s.overflow = 'hidden';
                            s.left = parseInt( cs.borderLeftWidth, 10 ) || 0;
                            s.top = parseInt( cs.borderTopWidth, 10 ) || 0;
                            s.zIndex = this.insetZIndex;

                            s = shape.style;
                            s.position = 'absolute';

                            //TODO handle wider border if needed due to very large offsets or spread
                            s.left = xOff - 20 + spread - blur;
                            s.top = yOff - 20 + spread - blur;
                            s.border = '20px solid ' + bs.color.value();
                        } else {
                            s.left = xOff - blur - spread;
                            s.top = yOff - blur - spread;
                            s.zIndex = this.outsetZIndex;

                            shape.filled = true;
                            shape.fillcolor = bs.color.value();

                            alpha = bs.color.alpha();
                            if( alpha < 1 ) {
                                shape.fill.opacity = alpha;
                            }
                        }

                        // Apply blur filter to the outer or inner element. Applying the blur filter twice with
                        // half the pixel value gives a shadow nearly identical to other browsers.
                        if( blur > 0 ) {
                            filter = 'progid:DXImageTransform.Microsoft.blur(pixelRadius=' + halfBlur + ')';
                            ss.filter = filter + ' ' + filter;
                        }

                        this.parent.getBox().appendChild( box );
                    }
                    return box;
                },

                destroy: function() {
                    var box = this._box;
                    if( box && box.parentNode ) {
                        box.parentNode.removeChild( box );
                    }
                    delete this._box;
                    delete this._shapes;
                }

            } );

        } // if( !PIE )




















        /**
         * Update position and/or size as necessary. Both move and resize events call
         * this rather than the updatePos/Size functions because sometimes, particularly
         * during page load, one will fire but the other won't.
         */
        function update( force ) {
            if( renderers ) {
                var el = element,
                    x = el.offsetLeft,
                    y = el.offsetTop,
                    w = el.offsetWidth,
                    h = el.offsetHeight,
                    i, len;

                if( force || x !== lastX || y !== lastY ) {
                    for( i = 0, len = renderers.length; i < len; i++ ) {
                        renderers[i].updatePos();
                    }
                    lastX = x;
                    lastY = y;
                }
                if( force || w !== lastW || h !== lastH ) {
                    for( i = 0, len = renderers.length; i < len; i++ ) {
                        renderers[i].updateSize();
                    }
                    lastW = w;
                    lastH = h;
                }
            }
        }

        /**
         * Handle property changes to trigger update when appropriate.
         */
        function propChanged() {
            if( renderers ) {
                var name = event.propertyName,
                    i, len, toUpdate;
                if( name === 'style.display' || name === 'style.visibility' ) {
                    for( i = 0, len = renderers.length; i < len; i++ ) {
                        renderers[i].updateVis();
                    }
                }
                else { //if( event.propertyName === 'style.boxShadow' ) {
                    toUpdate = [];
                    for( i = 0, len = renderers.length; i < len; i++ ) {
                        toUpdate.push( renderers[i] );
                    }
                    for( i = 0, len = toUpdate.length; i < len; i++ ) {
                        toUpdate[i].updateProps();
                    }
                }
            }
        }


        function ancestorPropChanged() {
            var name = event.propertyName;
            if( name === 'className' || name === 'id' ) {
                propChanged();
            }
        }


        function cleanup() {
            var i, len;

            // destroy any active renderers
            for( i = 0, len = renderers.length; i < len; i++ ) {
                renderers[i].destroy();
            }
            renderers = null;
            styleInfos = null;

            // remove any ancestor propertychange listeners
            if( ancestors ) {
                for( i = 0, len = ancestors.length; i < len; i++ ) {
                    ancestors[i].detachEvent( 'onpropertychange', ancestorPropChanged );
                }
                ancestors = null;
            }
        }



        function initAncestorPropChangeListeners() {
            var watch = element.currentStyle.getAttribute( PIE.CSS_PREFIX + 'watch-ancestors' ),
                i, a;
            if( watch ) {
                ancestors = [];
                watch = parseInt( watch, 10 );
                i = 0;
                a = element.parentNode;
                while( a && ( watch === 'NaN' || i++ < watch ) ) {
                    ancestors.push( a );
                    a.attachEvent( 'onpropertychange', ancestorPropChanged );
                    a = a.parentNode;
                }
            }
        }


        /**
         * Initialize
         */
        function init() {
            var el = element;

            // force layout so move/resize events will fire
            el.runtimeStyle.zoom = 1;

            // Create the style infos and renderers
            styleInfos = {
                background: new PIE.BackgroundStyleInfo( el ),
                border: new PIE.BorderStyleInfo( el ),
                borderImage: new PIE.BorderImageStyleInfo( el ),
                borderRadius: new PIE.BorderRadiusStyleInfo( el ),
                boxShadow: new PIE.BoxShadowStyleInfo( el )
            };

            var rootRenderer = new PIE.RootRenderer( el, styleInfos );
            renderers = [
                rootRenderer,
                new PIE.BoxShadowRenderer( el, styleInfos, rootRenderer ),
                new PIE.BackgroundAndBorderRenderer( el, styleInfos, rootRenderer ),
                new PIE.BorderImageRenderer( el, styleInfos, rootRenderer )
            ];

            // Add property change listeners to ancestors if requested
            initAncestorPropChangeListeners();

            update();
        }

    </script>

</PUBLIC:COMPONENT>
